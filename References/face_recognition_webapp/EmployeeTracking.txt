Employee Tracking

Menyimpan data dasar karyawan:

Tabel employees
CREATE TABLE employees (
    employee_id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    face_embedding VECTOR,  -- atau path file embedding
    department VARCHAR(50),
    role VARCHAR(50)
);


Tabel cameras 
CREATE TABLE cameras (
    camera_id VARCHAR(50) PRIMARY KEY,   -- "CAM1", "CAM2"...
    camera_name VARCHAR(100),            -- dari JSON "name"
    rtsp_url TEXT,                       -- "0" utk webcam, "rtsp://..." utk IP
    status VARCHAR(20) DEFAULT 'offline',-- runtime update
    is_active BOOLEAN DEFAULT FALSE,     -- runtime update
    config_path TEXT                     -- path JSON (opsional, untuk sinkronisasi)
);


tabel employee_tracking
CREATE TABLE employee_tracking (
    id SERIAL PRIMARY KEY,
    employee_id VARCHAR(50) REFERENCES employees(employee_id),
    camera_id VARCHAR(50) REFERENCES cameras(camera_id),
    last_seen TIMESTAMP NOT NULL,        -- update tiap wajah terdeteksi
    status VARCHAR(20) DEFAULT 'UNAVAILABLE' -- "AVAILABLE" / "OFFLINE"
);

tabel tabel notification
CREATE TABLE notifications (
    id SERIAL PRIMARY KEY,
    employee_id VARCHAR(50) REFERENCES employees(employee_id),
    camera_id VARCHAR(50) REFERENCES cameras(camera_id),
    type VARCHAR(50),            -- "EMPLOYEE_LOST", "CAMERA_DOWN"
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_read BOOLEAN DEFAULT FALSE
);

=================================================================================================

Berikut alur logika real-time:

1. Frame Capture
- Kamera mengirim stream (RTSP/HTTP).
- Frame diambil setiap interval (misal 1 FPS).

2. Face Detection + Recognition
- Deteksi wajah dengan model (MTCNN/RetinaFace).
- Ekstrak embedding dengan FaceNet, ArcFace, atau model lain.
- Bandingkan embedding dengan database employees.face_embedding.
- Threshold similarity → tentukan ID karyawan.

3. Update Status ke Database
- Jika wajah dikenali → update employee_tracking:
INSERT INTO employee_tracking (employee_id, camera_id, last_seen, status)
VALUES ('lee', 'CAM1', NOW(), 'AVAILABLE')
ON CONFLICT (employee_id) DO UPDATE 
SET camera_id=EXCLUDED.camera_id, 
    last_seen=EXCLUDED.last_seen, 
    status='AVAILABLE';
- Jika tidak dikenali atau tidak muncul dalam periode tertentu (misal >10 menit) → update status = 'UNAVAILABLE'.

4. Dashboard / Frontend
- Query employee_status untuk menampilkan card.
- Field ditampilkan:
	- Nama → dari tabel employees.
	- Status → AVAILABLE / UNAVAILABLE.
	- Last Seen → selisih NOW() - last_seen (contoh: "11 hours ago").
	- CAM-name → join dengan tabel cameras.
	- Track Location Button → ambil cameras.rtsp_url, arahkan ke player/iframe.


===================================================================================

📊 Flow Database ↔ Web Elemen
<header>
<datetime-display> → realtime dari server (tidak perlu DB).
<button_notification> → query notifications (WHERE is_read=false).
<button_settings> → CRUD employees & cameras (admin panel).
<cctv-feed-section>
<ai-status> → flag global dari sistem AI (bisa taruh di Redis atau 1 field status di DB).
<camera-stream> → ambil rtsp_url dari tabel cameras sesuai camera aktif.
<camera-buttons> → generate otomatis dari tabel cameras (atau dari folder JSON saat startup).
<employee-tracking-section>
<active-count> → COUNT(employee_tracking WHERE status='AVAILABLE').
<employee-name> → dari tabel employees.
<employee-camera> → JOIN dengan cameras.
<status-indicator-wrapper> → status AVAILABLE/OFFLINE dari employee_tracking.
<status_time> → hitung NOW() - last_seen. Jika >2 menit → trigger notifications.
<track-btn> → ambil rtsp_url dari cameras tempat employee terakhir terlihat.
<summary-stats>
<present-count> → jumlah status='AVAILABLE'.
<alert-count> → jumlah status='OFFLINE'.
<total-count> → COUNT(*) FROM employees.

✅ Flow Runtime
Startup → load semua JSON di camera_configs/ → sync ke cameras.
Loop inferensi AI:
Jika wajah terdeteksi → update employee_tracking.last_seen, status='AVAILABLE'.
Jika wajah hilang > 120s → update status='OFFLINE' + insert ke notifications.
Flask+SocketIO push perubahan DB ke Web UI:
Notifikasi baru → <button_notification>.
Kamera status → <camera-buttons> + <camera-stream>.
Employee status → <employee-item> + <summary-stats>.


🔗 Mapping Frontend ↔ Database
1. Header
- Datetime (#current-time, #current-date)
    - Tidak butuh DB → langsung dari datetime.now() di backend.
- Notification (#notification-btn, #notification-list)
    - Event: socket.on('notification')
    - DB: notifications
    SELECT * FROM notifications WHERE is_read = FALSE ORDER BY created_at DESC;
    - Insert baru setiap ada:
    - Employee offline > X menit.
    - Camera is_active = FALSE.

2. Live CCTV Feed
- AI Status (#ai-status-indicator)
    - Event: socket.on('ai_status')
    - DB: system_status atau hanya push dari backend (tidak wajib disimpan).
- Video Stream (#camera-stream)
    - Event: socket.on('video_frame')
    - DB: ambil rtsp_url dari tabel cameras.
    SELECT rtsp_url FROM cameras WHERE camera_id = ?;

- Camera Buttons (#camera-buttons)
    - Render dari AppState.cameras.
    - DB: cameras table → list semua kamera.
    SELECT camera_id, camera_name, is_active FROM cameras;
    - OnClick → socket.emit('switch_camera', {camera_id}).

3. Employee Tracking

- Employee List (#employee-list)
    - Event: socket.on('employee_status_update')
    - DB query JOIN:
    SELECT e.employee_id, e.name, et.status, et.last_seen, c.camera_name
    FROM employee_tracking et
    JOIN employees e ON et.employee_id = e.employee_id
    LEFT JOIN cameras c ON et.camera_id = c.camera_id;
    - Status Dot (.status-dot)
        - Green → AVAILABLE
        - Red → OFFLINE
    - Last Seen (.status-time)
        Backend compare NOW() - last_seen.
        Jika lebih dari threshold → update status = 'OFFLINE' dan insert ke notifications.
    - Track Button (.track-btn)
        - Query lokasi kamera terakhir dari employee_tracking.

4. Summary Stats (#present-count, #alert-count, #total-count)
    - DB Aggregation:
        SELECT 
            SUM(CASE WHEN status='AVAILABLE' THEN 1 ELSE 0 END) AS present,
            SUM(CASE WHEN status='OFFLINE' THEN 1 ELSE 0 END) AS alert,
            COUNT(DISTINCT employee_id) AS total
        FROM employee_tracking;

5. Report Page
    - Masih placeholder → akan pakai tabel:
        - employee_tracking (historical presence log).
        - notifications (alert history).
    - Bisa buat tabel attendance_logs khusus untuk daily summary:
    CREATE TABLE attendance_logs (
        log_id INT AUTO_INCREMENT PRIMARY KEY,
        employee_id INT NOT NULL,
        date DATE NOT NULL,
        first_seen DATETIME,
        last_seen DATETIME,
        total_duration INT, -- dalam menit
        status ENUM('PRESENT','ABSENT','LATE','LEFT_EARLY'),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (employee_id) REFERENCES employees(employee_id)
    );



⚙️ Workflow Backend ↔ Database ↔ Frontend
1. Startup
    - Load employees + cameras → emit initial_data.
2. AI Recognition (Jetson/Server)
    - Jika wajah match → UPDATE employee_tracking SET status='AVAILABLE', last_seen=NOW(), camera_id=?.
    - Emit employee_detected.
3. Monitoring Loop
    - Cek NOW() - last_seen.
    - Jika > threshold → update status='OFFLINE' + insert notifications.
    - Emit employee_status_update.
4. Frontend
    - Render ulang employee list, summary, dan notification badge.

===================================================================================
Integrasi UI

- Employee Card hanya muncul jika employee_id ada di DB.
- Nama → join dari employees.name.
- Status (Available/Unavailable) → hasil real-time tracking.
- Duration-time (Last Seen) → relative timestamp.
- CAM-name → ambil dari cameras.camera_name.
- Track Location Button → arahkan ke cameras.rtsp_url.

👉 Dengan desain ini:

- Semua karyawan ada di UI meski tidak terdeteksi (akan tampil Unavailable).
- Status berubah otomatis saat wajah dikenali.
- Bisa support multi-camera dan multi-location.